<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - render-to-texture</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
      color: #ffffff;
      font-family:Monospace;
      font-size:13px;
      text-align:center;
      font-weight: bold;
      background-color: #000000;
      margin: 0px;
      overflow: hidden;
      }

      #info {
      position: absolute;
      top: 0px; width: 100%;
      padding: 5px;
      }

      a {
      color: #ffffff;
      }

    </style>
  </head>


  <body>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>

    <div id="container"></div>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
    <script src="js/libs/three.min.js"></script>
    <script src="js/libs/stats.min.js"></script>
    <script src="js/libs/TrackballControls.js"></script>
    <script src="js/libs/OrbitControls.js"></script>
    <script src="js/libs/Detector.js"></script>

    <!-- Shaders -->
    <script type="x-shader/x-vertex" id="raytracer-vert">
        //! VERTEX

        /* the position defines the size of the quad */
        /* (that is, how many pixels are rasterized) */

        /* the sceneTilePosition defines what part of the scene we are rendering */
        /* -1 to 1 coords means the whole scene */
        /* if it takes position.xy values then we render a part of the image */
        attribute vec2 sceneTilePosition;

      uniform vec3 uEyePos;

      uniform mat4 uViewProjectionInverse;

      varying vec3 vRayDir;
      varying vec3 vPointLight;

      varying vec2 discardTexCoord;

      /* varying vec2 debug; */

      void main( void )
      {
        vec3 uPointLight = vec3(0);


        gl_Position = vec4(position.xy,-1., 1);
        /* reframe coords between 0 1*/
        discardTexCoord = (sceneTilePosition + 1.)/2.;
        /* discardTexCoord = (position.xy + 1.)/2.; */
        /* debug=(position.xy+1.)/2.; */
        /* point light is attached to the camera */
        vPointLight = uPointLight+uEyePos;

        /* computing the ray direction vector  */
        /* we have to unproject the near plane's tile */

  vec3 tilePosition = vec3(sceneTilePosition ,-1.);
  /* vec3 tilePosition = vec3(position.xy ,-1.); */
  /* tilePosition is a vector like (x,y,-1) with -1<=x,y<=1 */
  /* the origin is bottom left */


  /* apply the projection to the vector */
  /* see https://github.com/mrdoob/three.js/blob/master/src/math/Vector3.js */
  /* function apply projection */

  // perspective divide
  float d = 1. / (uViewProjectionInverse[3].x * tilePosition.x +
                  uViewProjectionInverse[3].y * tilePosition.y +
                  uViewProjectionInverse[3].z * tilePosition.z +
                  uViewProjectionInverse[3].w );

  /* I predict this update soon */
  /* vRayDir = d * vec3 ( transpose( mat3x4(uViewProjectionInverse) ) * vec4(tilePosition,1.) ); */

  vRayDir.x = ( uViewProjectionInverse[0].x * tilePosition.x +
                uViewProjectionInverse[0].y * tilePosition.y +
                uViewProjectionInverse[0].z  * tilePosition.z +
                uViewProjectionInverse[0].w );

  vRayDir.y = ( uViewProjectionInverse[1].x * tilePosition.x +
                uViewProjectionInverse[1].y * tilePosition.y +
                uViewProjectionInverse[1].z  * tilePosition.z +
                uViewProjectionInverse[1].w );

  vRayDir.z = ( uViewProjectionInverse[2].x * tilePosition.x +
                uViewProjectionInverse[2].y * tilePosition.y +
                uViewProjectionInverse[2].z * tilePosition.z +
                uViewProjectionInverse[2].w );

  vRayDir = normalize( d * vRayDir - uEyePos );
}
</script>
<script type="x-shader/x-fragment" id="raytracer-frag">
//! FRAGMENT

#define MAX_DISTANCE 4096.


/* STRUCT DEFINITION */
varying vec3 vRayDir;

varying vec2 discardTexCoord;

uniform vec3 uEyePos;
uniform vec4 uSpheres[NUMBER_OF_SPHERES];

varying vec3 vPointLight;
/* varying vec3 vDirLight; */


struct Ray {
  vec3 origin;
  vec3 direction;
} ;

struct IntersectItem {
  float dist;
  vec3 p;
  vec3 normalVector;
  vec3 color;
};

struct Light {
  vec3 ambient;
  vec3 diffuse;
  vec3 specular;
};

struct ObjectMaterial {
  float ambientCoef;
  float diffuseCoef;
  float specularCoef;
  float shininess;
};

/* CODE */




Light sceneLight = Light (  vec3(0.1, 0.1, 0.1), //ambient
                            vec3(1., 0.8431372549, 0.),  //diffuse
                            /* vec3(0.5, 0.5, 0.5),  //diffuse */
                            vec3(1., 1., 1.));  //specular

ObjectMaterial sceneMaterial = ObjectMaterial (
                                               0.1, //ambient coeff
                                               0.8, //diffuse coeff
                                               1., //specular coeff
                                               50. //shininess
                                               );

vec3 sphereColor = vec3(0.9, 0., 0.);

/* normal vector of a sphere at given point */
vec3 sphereNorm( in vec3 pt, in vec4 s )
{
  return pt - s.xyz;
}

vec3 getPOutOfRay (in Ray r, in float t)
{
  return r.origin+r.direction*t;
}


bool isPointWithinBounds(in vec3 vp, in vec3 axis,in float inf,in float sup)
{
  float vpDP=dot(vp,axis);
  return ((vpDP > inf) && (vpDP < sup));
}





/* return min intersection between two intersection */
/* if no inter then return i1 */
IntersectItem minInter(in IntersectItem i1,
                       in IntersectItem i2)
{
  if ((i2.dist < MAX_DISTANCE) && (i2.dist < i1.dist))
    return i2;
  else
    return i1;
}

void sphereInter(in Ray r,in vec4 s, out IntersectItem ret)
{
  ret.dist=MAX_DISTANCE;
  ret.color=sphereColor;

  // Transform the ray into object space
  vec3 oro = r.origin - s.xyz;
  float b = 2.0 * dot(oro, r.direction);
  float c = dot(oro, oro) - s.w * s.w; // w is the sphere radius

  /* a is 1. because ray direction is normalized */
  float d = b * b - 4.0 * c;

  if(d >= 0.0)
    {
      float t=(-b - sqrt(d)) * 0.5;
      ret.dist= (t<0. ? MAX_DISTANCE : t);
      ret.p=getPOutOfRay(r,ret.dist);
      ret.normalVector=sphereNorm(ret.p,s);
    }
}


void intersect(in Ray r, out IntersectItem firstIntersected )
{
  firstIntersected.dist=MAX_DISTANCE;

  IntersectItem tmpIntersected;
  vec4 curSphere;

  for (int i = 0; i < NUMBER_OF_SPHERES; i++)
    {
      /* fetch current sphere */
      curSphere=uSpheres[i];
      sphereInter(r,curSphere,tmpIntersected);
      firstIntersected = minInter(firstIntersected,tmpIntersected);
    }
}

vec4 computeIntersectedColor (in IntersectItem boom)
{
  vec3 lightDir = normalize(vPointLight - boom.p);
  /* normalize the normal vector */
  boom.normalVector = normalize(boom.normalVector);

  vec3 eyeToP = normalize(boom.p - uEyePos);
  /* col = texture2D(uBackgroundRTT,abs(normalize(reflect(eyeToP,boom.normalVector).xy))).xyz + */
  /*   vec3(0.,0.,0.) ; */
  /* return; */
  float ambientContrib = sceneMaterial.ambientCoef;

  float diffuseContrib = sceneMaterial.diffuseCoef * max(dot(lightDir,boom.normalVector),0.);

  float specularContrib = (pow(max(dot(reflect(lightDir,boom.normalVector),eyeToP),0.),sceneMaterial.shininess));

  return vec4(vec3(0.,67.,47.)/100. *(diffuseContrib + specularContrib),
              1.);
}

vec4 discardPixel ()
{
      return vec4(normalize(abs(vRayDir)),1.);
}

void main( void )
{
  // Cast a ray out from the eye position into the scene
  Ray r=Ray(uEyePos,normalize(vRayDir));
  IntersectItem objectBoom;
  // See if the ray intesects with any objects.
  // Provides the normal of the nearest intersection point and color
  intersect(r,objectBoom);
  /* intersection! */
  if ( objectBoom.dist < MAX_DISTANCE )
    {
      gl_FragColor = computeIntersectedColor(objectBoom);
      return;
    }
  else
    {
      gl_FragColor = discardPixel();
      return;
    }
}
</script>
<script type="x-shader/x-vertex" id="vertexshader">
  varying vec2 vTexCoord;

void main(void) {
  vTexCoord = vec2(position);
  gl_Position = vec4(position, 1.0);
}
</script>
<script type="x-shader/x-fragment" id="fragmentPostProcess">
  varying vec2 vTexCoord;
uniform sampler2D uTex;

void main ()
{
  gl_FragColor = texture2D(uTex,(vTexCoord/2.+vec2(0.5,0.5)));
}
</script>
<script type="text/javascript">

  // @see http://paulirish.com/2011/requestanimationframe-for-smart-animating/
  window.requestAnimFrame = (function(){
      return  window.requestAnimationFrame       ||
          window.webkitRequestAnimationFrame ||
          window.mozRequestAnimationFrame    ||
          window.oRequestAnimationFrame      ||
          window.msRequestAnimationFrame     ||
          function(/* function */ callback, /* DOMElement */ element){
              window.setTimeout(callback, 1000 / 60);
          };
  })();


  var WIDTH = window.innerWidth;
  var HEIGHT = window.innerHeight;

  // get the DOM element to attach to
  // - assume we've got jQuery to hand
  var container = $('#container');

  // create a WebGL renderer, camera
  var rayTracingRenderer = new THREE.WebGLRenderer();
  rayTracingRenderer.autoClear=false;
  rayTracingRenderer.autoClearColor=false;
  rayTracingRenderer.setSize(WIDTH,HEIGHT);

  var pars={ minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat };
  rayTracingRenderer.rTracedTexture = new THREE.WebGLRenderTarget( WIDTH,
                                                                   HEIGHT);

  var viewProjectionInverse = new THREE.Matrix4();
  var eyePos = new THREE.Vector3();

  var stats = new Stats();

  var camera = new THREE.PerspectiveCamera( 60,
                                            WIDTH / HEIGHT,
                                            1,
                                            1000 );

  camera.position.z = 500;
  camera.position.set(0.3,0.1,-1.);
  camera.up = new THREE.Vector3(0,1,0);
  camera.lookAt(new THREE.Vector3(0,0,0));
  var controls = new THREE.TrackballControls( camera );

  controls.rotateSpeed = 1.0;
  controls.zoomSpeed = 1.2;
  controls.panSpeed = 0.8;

  controls.noZoom = false;
  controls.noPan = false;

  controls.staticMoving = true;
  controls.dynamicDampingFactor = 0.3;

  controls.keys = [ 65, 83, 68 ];

  controls.addEventListener( 'change', render );

  var scene = new THREE.Scene();

  // attach the render-supplied DOM element
  // $container.append(rayTracingRenderer.domElement);
  container.append(rayTracingRenderer.domElement);

  // create the Stats element and append it to the Dome
  var stats = new Stats();
  stats.domElement.style.position = 'absolute';
  stats.domElement.style.top = '0px';
  container.append( stats.domElement );


  var attributes = {
      sceneTilePosition : {
          type : 'v2',
          value : [
              new THREE.Vector2(-1,1),
              new THREE.Vector2(1,1),
              new THREE.Vector2(-1,-1),
              new THREE.Vector2(1,-1)
          ]
      }
  };
  var sphereData = [];

  for (var i=0;i<10;i++)
  {
      sphereData.push(new THREE.Vector4(
          (Math.random() - 0.5) * 1000,
          (Math.random() - 0.5) * 1000,
          (Math.random() - 0.5) * 1000,
          (Math.random() - 0.5) * 1000));
  }


  var uniforms = {
      uTime:  {
          type: 'f', // a float
          value: 1
      },
      uEyePos : {
          type: 'v3',
          value : eyePos
      },
      uViewProjectionInverse: {
          type: 'm4',
          value: viewProjectionInverse
      },
      uSpheres : {
          type : 'v4v',
          value : sphereData
      }
  };

  var defines = "#define NUMBER_OF_SPHERES "+
    sphereData.length+"\n";

  var rayTracingMaterial = new THREE.ShaderMaterial({
      uniforms:         uniforms,
      attributes:     attributes,
      vertexShader:   $('#raytracer-vert').text(),
      fragmentShader: defines +
          $('#raytracer-frag').text()
  });

  function updateUniforms(camera,view,eyepos) {
      camera.updateMatrixWorld();
      camera.updateMatrix();
      camera.projectionMatrixInverse.getInverse( camera.projectionMatrix );
      view.multiplyMatrices( camera.matrixWorld,
                             camera.projectionMatrixInverse );
      view.transpose();
      eyePos.copy(camera.localToWorld(new THREE.Vector3(0.,0.,0.)));
  }


  var rayQuad = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2),
                                rayTracingMaterial
                              );
  rayQuad.geometry.computeBoundingBox();
  rayQuad.geometry.computeBoundingSphere();

  //add the quad to the scene
  scene.add(rayQuad);
  var rayTracingCamera = new THREE.OrthographicCamera( WIDTH / - 2,
                                                       WIDTH / 2,
                                                       HEIGHT / 2,
                                                       HEIGHT / - 2,
                                                       -1, 10000 );
  function animate() {
      requestAnimationFrame( animate );
      controls.update();
  }
  // draw!
  function render()
  {
      updateUniforms(camera,viewProjectionInverse,eyePos);
      // render ray traced scene
      rayTracingRenderer.render(scene, rayTracingCamera);
      // set up the next call
      stats.update();
  }

  // first call
  animate();
</script>
</body>
</html>
